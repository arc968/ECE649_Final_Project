/*
Andrew R. Courtemanche 2020/12
*/

/*
This file uses the eUSCI module configured as an SPI master to output the very timing sensitive protocol
the WS2812B individually addressable LEDs use.

The SPI module is configured with a 2.5MHz bit clock, which means a bit is shifted out every 0.4us.
Each bit is encoded as a 1.2us signal split into one high period and one low period. The ratio
between these high and low periods encode a single bit.

To encode a 0 bit: 0.4us high, 0.8us low
To encode a 1 bit: 0.8us high, 0.4us low

Since a bit is shifted out every 0.4us, we can encode these signals as a series of bits.
Each color bit is encoded as three bits for transmission. A 0 bit is encoded as 0b100
and a 1 bit is encoded as 0b110. This means a single color byte is encoded as three bytes
for transmission. Furthermore, a full RGB color is encoded as a series of 9 bytes.

For example:
11001010 would be encoded as:
11011010 01001101 00110100

For example:
RGB 11111111 00000000 10101010 would be encoded as:
10010010 01001001 00100100 11011011 01101101 10110110 11010011 01001101 00110100
G        G        G        R        R        R        B        B        B
Keep in mind RGB is converted to GRB for transmission.
*/

#include "led_panel.h"

#define ARC_MSP_USE_GPIO
#define ARC_MSP_TYPE_msp430fr6989
#include "arc_msp_helper.h"

#include <msp430.h>
#include <stdint.h>
#include <stdbool.h>

//LUT for first TX byte
__attribute__ ((lower))
const uint8_t led_TX_LUT0[] = {
  0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
  0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
  0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x93, 0x93, 0x93, 0x93,
  0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93,
  0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93,
  0x93, 0x93, 0x93, 0x93, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a,
  0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a,
  0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a,
  0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b,
  0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b,
  0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0xd2, 0xd2, 0xd2, 0xd2,
  0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2,
  0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2,
  0xd2, 0xd2, 0xd2, 0xd2, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3,
  0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3,
  0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3,
  0xda, 0xda, 0xda, 0xda, 0xda, 0xda, 0xda, 0xda, 0xda, 0xda, 0xda, 0xda,
  0xda, 0xda, 0xda, 0xda, 0xda, 0xda, 0xda, 0xda, 0xda, 0xda, 0xda, 0xda,
  0xda, 0xda, 0xda, 0xda, 0xda, 0xda, 0xda, 0xda, 0xdb, 0xdb, 0xdb, 0xdb,
  0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb,
  0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb,
  0xdb, 0xdb, 0xdb, 0xdb
};

//LUT for second TX byte
__attribute__ ((lower))
const uint8_t led_TX_LUT1[] = {
  0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x4d, 0x4d, 0x4d, 0x4d,
  0x4d, 0x4d, 0x4d, 0x4d, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69,
  0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x49, 0x49, 0x49, 0x49,
  0x49, 0x49, 0x49, 0x49, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d,
  0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x6d, 0x6d, 0x6d, 0x6d,
  0x6d, 0x6d, 0x6d, 0x6d, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
  0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x69, 0x69, 0x69, 0x69,
  0x69, 0x69, 0x69, 0x69, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d,
  0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x4d, 0x4d, 0x4d, 0x4d,
  0x4d, 0x4d, 0x4d, 0x4d, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69,
  0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x49, 0x49, 0x49, 0x49,
  0x49, 0x49, 0x49, 0x49, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d,
  0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x6d, 0x6d, 0x6d, 0x6d,
  0x6d, 0x6d, 0x6d, 0x6d, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
  0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x69, 0x69, 0x69, 0x69,
  0x69, 0x69, 0x69, 0x69, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d,
  0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x4d, 0x4d, 0x4d, 0x4d,
  0x4d, 0x4d, 0x4d, 0x4d, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69,
  0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x49, 0x49, 0x49, 0x49,
  0x49, 0x49, 0x49, 0x49, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d,
  0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x6d, 0x6d, 0x6d, 0x6d,
  0x6d, 0x6d, 0x6d, 0x6d
};

//LUT for third TX byte
__attribute__ ((lower))
const uint8_t led_TX_LUT2[] = {
  0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36,
  0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6,
  0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36,
  0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6,
  0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36,
  0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6,
  0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36,
  0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6,
  0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36,
  0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6,
  0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36,
  0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6,
  0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36,
  0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6,
  0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36,
  0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6,
  0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36,
  0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6,
  0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36,
  0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6,
  0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6, 0x24, 0x26, 0x34, 0x36,
  0xa4, 0xa6, 0xb4, 0xb6
};

//unused function, was used for early implementations with a different set of LUTs
//inline void led_byte_to_TX(uint8_t * buf, uint8_t col) {
//    buf[0] = led_TX_LUT0[((col & 0b11100000) >> 5)];
//    buf[1] = led_TX_LUT1[((col & 0b00011000) >> 3)];
//    buf[2] = (led_TX_LUT0[col & 0b00000111] << 1);
//
//    buf[0] = led_TX_LUT0[(col & 0b11100000) >> 5];
//    buf[1] = led_TX_LUT1[(col & 0b00011000) >> 3];
//    buf[2] = led_TX_LUT2[(col & 0b00000111)];
//
//    buf[0] = led_TX_LUT[col*3];
//    buf[1] = led_TX_LUT[col*3+1];
//    buf[2] = led_TX_LUT[col*3+2];
//}

//converts a 24-bit RGB value into a 9-byte GRB encoded stream for transmission
//uses LUTs for performance
static inline void led_RGB_to_TX(uint8_t * buf, uint8_t * rgb) {
//    led_byte_to_TX(buf, rgb[1]);
//    led_byte_to_TX(buf+3, rgb[0]);
//    led_byte_to_TX(buf+6, rgb[2]);

//    buf[0] = led_TX_LUT0[(rgb[1] & 0b11100000) >> 5];
//    buf[3] = led_TX_LUT0[(rgb[0] & 0b11100000) >> 5];
//    buf[6] = led_TX_LUT0[(rgb[2] & 0b11100000) >> 5];
//    buf[1] = led_TX_LUT1[(rgb[1] & 0b00011000) >> 3];
//    buf[4] = led_TX_LUT1[(rgb[0] & 0b00011000) >> 3];
//    buf[7] = led_TX_LUT1[(rgb[2] & 0b00011000) >> 3];
//    buf[2] = led_TX_LUT2[(rgb[1] & 0b00000111)];
//    buf[5] = led_TX_LUT2[(rgb[0] & 0b00000111)];
//    buf[8] = led_TX_LUT2[(rgb[2] & 0b00000111)];

    buf[0] = led_TX_LUT0[rgb[1]];
    buf[3] = led_TX_LUT0[rgb[0]];
    buf[6] = led_TX_LUT0[rgb[2]];

    buf[1] = led_TX_LUT1[rgb[1]];
    buf[4] = led_TX_LUT1[rgb[0]];
    buf[7] = led_TX_LUT1[rgb[2]];

    buf[2] = led_TX_LUT2[rgb[1]];
    buf[5] = led_TX_LUT2[rgb[0]];
    buf[8] = led_TX_LUT2[rgb[2]];
}

//make sure LED strips have enough time to reset
//writes a bunch of zero bytes to panel
void led_flush(void) {
    for (uint16_t i=0; i<100; i++) {
        while (!(UCB0IFG & UCTXIFG));
        UCB0TXBUF = 0;
        while (!(UCB1IFG & UCTXIFG));
        UCB1TXBUF = 0;
    }
}

//draw given 32x32 24 bit RGB framebuffer
void led_draw(uint8_t * rgb_buf) {
    uint16_t GIE_BACKUP = _get_SR_register() & GIE; //store GIE
    __asm(" DINT \n NOP \n"); //disable interrupts

    while (!(UCB0IFG & UCTXIFG)); //make sure nothing is being transmitted already
    while (!(UCB1IFG & UCTXIFG)); //make sure nothing is being transmitted already

    uint_fast8_t tx_buf_select = 0;
    uint8_t tx_buf[2][2][9]; //[channel][buffer][data]

    //do address calculation ahead of time for performance
    uintptr_t tx_ch0_buf0_ptr = (uintptr_t) &tx_buf[0][0][0];
    uintptr_t tx_ch0_buf1_ptr = (uintptr_t) &tx_buf[0][1][0];
    uintptr_t tx_ch1_buf0_ptr = (uintptr_t) &tx_buf[1][0][0];
    uintptr_t tx_ch1_buf1_ptr = (uintptr_t) &tx_buf[1][1][0];

    //initialize transmission buffers
    led_RGB_to_TX((uint8_t *) tx_ch0_buf0_ptr, &rgb_buf[0]);
    led_RGB_to_TX((uint8_t *) tx_ch1_buf0_ptr, &rgb_buf[0 + ((LED_CHANNEL_WIDTH*LED_CHANNEL_HEIGHT)*3)]);

    //set DMA src address to correct buffers
    DMA0SA = tx_ch0_buf0_ptr;
    DMA1SA = tx_ch1_buf0_ptr;

    //enable DMA0 and provide rising edge to kick it off
    DMA0CTL |= DMAEN;
    UCB0IFG &= ~UCTXIFG;
    UCB0IFG |=  UCTXIFG;

    //enable DMA1 and provide rising edge to kick it off
    DMA1CTL |= DMAEN;
    UCB1IFG &= ~UCTXIFG;
    UCB1IFG |=  UCTXIFG;

    volatile uint16_t x=1; //it breaks if this is not volatile
    for (volatile uint16_t y=0; y<LED_CHANNEL_HEIGHT; y++) { //it breaks if this is not volatile
        for (; x<LED_CHANNEL_WIDTH; x++) {
            tx_buf_select = (tx_buf_select == 0) ? 1 : 0; //switch active buffer

            uintptr_t tx_ch0_buf_temp_ptr;
            uintptr_t tx_ch1_buf_temp_ptr;

            //store address of transmission buffers
            if (tx_buf_select == 0) {
                tx_ch0_buf_temp_ptr = tx_ch0_buf0_ptr;
                tx_ch1_buf_temp_ptr = tx_ch1_buf0_ptr;
            } else {
                tx_ch0_buf_temp_ptr = tx_ch0_buf1_ptr;
                tx_ch1_buf_temp_ptr = tx_ch1_buf1_ptr;
            }

            //set DMA src address to correct buffers
            //this can be done while the DMA is running because it internally copies these addresses to temporary registers
            DMA0SA = tx_ch0_buf_temp_ptr;
            DMA1SA = tx_ch1_buf_temp_ptr;

            //fill the transmit buffers with the next 18 bytes to be transmitted, flipping the odd rows because of the way the LED panel is constructed
            if ((y & 0x1) == 0) { //even row
                led_RGB_to_TX((uint8_t *) tx_ch0_buf_temp_ptr, &rgb_buf[(x+(y*LED_CHANNEL_WIDTH)) * 3]);
                led_RGB_to_TX((uint8_t *) tx_ch1_buf_temp_ptr, &rgb_buf[((x+(y*LED_CHANNEL_WIDTH)) * 3) + ((LED_CHANNEL_WIDTH*LED_CHANNEL_HEIGHT)*3)]);
            } else { //odd row
                led_RGB_to_TX((uint8_t *) tx_ch0_buf_temp_ptr, &rgb_buf[((LED_CHANNEL_WIDTH-1-x)+(y*LED_CHANNEL_WIDTH)) * 3]);
                led_RGB_to_TX((uint8_t *) tx_ch1_buf_temp_ptr, &rgb_buf[(((LED_CHANNEL_WIDTH-1-x)+(y*LED_CHANNEL_WIDTH)) * 3) + ((LED_CHANNEL_WIDTH*LED_CHANNEL_HEIGHT)*3)]);
            }

            //wait for DMA to finish, restart it immediately
            while (DMA0CTL & DMAEN);
            DMA0CTL |= DMAEN;
            while (DMA1CTL & DMAEN);
            DMA1CTL |= DMAEN;
        }
        x=0;
    }

    //wait for DMA to finish, send a 0 to start resetting the panel
    while (DMA0CTL & DMAEN);
    UCB0TXBUF = 0;
    while (DMA1CTL & DMAEN);
    UCB1TXBUF = 0;

    __asm(" NOP \n");
    //_enable_interrupts();
    __asm(" BIS.B %0, SR \n NOP \n"::"r"(GIE_BACKUP)); //restore GIE
}

//initialize required registers
void led_init(void) {
    //P1.6 UCB0SIMO
    //P4.0 UCB1SIMO
    arc_msp_setup(); //setup GPIO

    //SPI config
    /*
    https://www.ti.com/lit/ug/slau627a/slau627a.pdf
    page 17:
    P1.6 UCB0SIMO
    P4.0 UCB1SIMO
    */
    pinFunc(&P(1,6), 1); //configure pin functions
    pinFunc(&P(4,0), 2); //configure pin functions

    UCB0BRW = 0; //do not divide BRCLK
    UCB1BRW = 0; //do not divide BRCLK

    UCB0CTLW0 = UCMSB | UCMST | UCSYNC | UCSSEL__SMCLK; //MSB first, Master mode, SPI, use SMCLK as clock source
    UCB1CTLW0 = UCMSB | UCMST | UCSYNC | UCSSEL__SMCLK; //MSB first, Master mode, SPI, use SMCLK as clock source
    //end SPI config

    //DMA config
    DMACTL0 = DMA0TSEL__UCB0TXIFG0 | DMA1TSEL__UCB1TXIFG0; //select DMA triggers
    //DMACTL4 = ROUNDROBIN;

    DMA0CTL = DMADT_0 | DMASRCINCR_3 | DMADSTBYTE | DMASRCBYTE; //single transfer mode, increment source address, byte destination, byte source
    DMA1CTL = DMADT_0 | DMASRCINCR_3 | DMADSTBYTE | DMASRCBYTE; //single transfer mode, increment source address, byte destination, byte source

    DMA0SA = 0; //initialize source address to zero, will be changed later
    DMA1SA = 0; //initialize source address to zero, will be changed later

    DMA0DA = 0x0640 + 0x000E; //UCB0TXBUF as destination address
    DMA1DA = 0x0680 + 0x000E; //UCB1TXBUF as destination address

    DMA0SZ = 9; //transfer 9 bytes
    DMA1SZ = 9; //transfer 9 bytes
}
